---
alwaysApply: true
---
# Data Handling Patterns

## Overview
This document defines the strict patterns for data retrieval, mutations, and validation in the FlashyCardyCourse application. These patterns ensure type safety, security, and consistency across the codebase.

## Core Principles

### 1. Database Operations: Helper Functions in `src/db/queries/` ONLY
ALL database operations (reads and writes) MUST be performed through helper functions located in the `src/db/queries/` directory. NEVER write raw database queries directly in Server Components or Server Actions.

### 2. Data Retrieval: Server Components call Query Helpers
Server Components fetch data by calling query helper functions from `src/db/queries/`. The helpers handle authentication, ownership verification, and database queries.

### 3. Mutations: Server Actions call Mutation Helpers
Server Actions validate input with Zod, then call mutation helper functions from `src/db/queries/`. The helpers handle authentication, ownership verification, and database modifications.

### 4. Validation: Zod in Server Actions
All data passed to Server Actions MUST be validated using Zod schemas before calling mutation helpers.

### 5. Type Safety: TypeScript Types ONLY
Server Actions and query helpers MUST have explicit TypeScript types for parameters. NEVER use `FormData` as a parameter type.

---

## Directory Structure

### Query Helpers Organization
All database operations MUST be organized in the `src/db/queries/` directory:

```
src/db/queries/
├── deck-queries.ts     # Deck read operations
├── deck-mutations.ts   # Deck write operations (create, update, delete)
├── card-queries.ts     # Card read operations
├── card-mutations.ts   # Card write operations
└── types.ts           # Shared types for queries
```

### File Naming Conventions
- `*-queries.ts`: Read operations (SELECT queries)
- `*-mutations.ts`: Write operations (INSERT, UPDATE, DELETE)
- `types.ts`: Shared TypeScript types and interfaces

### Types File Structure

```typescript
// src/db/queries/types.ts
import type { InferSelectModel, InferInsertModel } from "drizzle-orm";
import { decksTable, cardsTable } from "@/db/schema";

// Database model types (for SELECT queries)
export type Deck = InferSelectModel<typeof decksTable>;
export type Card = InferSelectModel<typeof cardsTable>;

// Insert types (for INSERT operations)
export type NewDeck = InferInsertModel<typeof decksTable>;
export type NewCard = InferInsertModel<typeof cardsTable>;

// Action result types (for Server Actions)
export type ActionResult<T = void> =
  | { success: true; data: T }
  | { success: false; error: string };
```

---

## Query Helper Patterns

### Basic Query Helper Structure

```typescript
// src/db/queries/deck-queries.ts
import { auth } from "@clerk/nextjs/server";
import { db } from "@/db";
import { decksTable, cardsTable } from "@/db/schema";
import { eq, and, desc } from "drizzle-orm";
import type { Deck, Card } from "./types";

/**
 * Get all decks for the authenticated user
 * @returns Array of decks owned by the user
 * @throws Error if user is not authenticated
 */
export async function getUserDecks(): Promise<Deck[]> {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))
    .orderBy(desc(decksTable.createdAt));
  
  return decks;
}

/**
 * Get a single deck by ID with ownership verification
 * @param deckId - The deck ID to fetch
 * @returns Deck object or null if not found
 * @throws Error if user is not authenticated
 */
export async function getDeckById(deckId: number): Promise<Deck | null> {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .limit(1);
  
  return deck ?? null;
}

/**
 * Get all cards for a specific deck with ownership verification
 * @param deckId - The deck ID to fetch cards for
 * @returns Array of cards for the deck
 * @throws Error if user is not authenticated or doesn't own the deck
 */
export async function getCardsByDeckId(deckId: number): Promise<Card[]> {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // Verify deck ownership first
  const deck = await getDeckById(deckId);
  if (!deck) {
    throw new Error("Deck not found");
  }
  
  // Now safe to fetch cards
  const cards = await db
    .select()
    .from(cardsTable)
    .where(eq(cardsTable.deckId, deckId))
    .orderBy(desc(cardsTable.createdAt));
  
  return cards;
}
```

---

## Data Retrieval Patterns

### Server Component Data Fetching

#### Pattern: Fetch User's Data
```typescript
// src/app/dashboard/page.tsx
import { redirect } from "next/navigation";
import { getUserDecks } from "@/db/queries/deck-queries";

export default async function DashboardPage() {
  // Call query helper - it handles auth and ownership verification
  let decks;
  
  try {
    decks = await getUserDecks();
  } catch (error) {
    // If unauthorized, redirect to home
    redirect("/");
  }
  
  return (
    <div>
      {decks.map((deck) => (
        <div key={deck.id}>{deck.name}</div>
      ))}
    </div>
  );
}
```

#### Pattern: Fetch Single Resource
```typescript
// src/app/dashboard/decks/[id]/page.tsx
import { redirect, notFound } from "next/navigation";
import { getDeckById } from "@/db/queries/deck-queries";
import { getCardsByDeckId } from "@/db/queries/card-queries";

interface PageProps {
  params: Promise<{ id: string }>;
}

export default async function DeckPage({ params }: PageProps) {
  const { id } = await params;
  const deckId = parseInt(id);
  
  if (isNaN(deckId)) {
    notFound();
  }
  
  // Fetch deck using query helper - handles auth & ownership
  let deck;
  try {
    deck = await getDeckById(deckId);
  } catch (error) {
    redirect("/");
  }
  
  if (!deck) {
    notFound();
  }
  
  // Fetch related cards using query helper
  let cards;
  try {
    cards = await getCardsByDeckId(deckId);
  } catch (error) {
    redirect("/");
  }
  
  return (
    <div>
      <h1>{deck.name}</h1>
      {cards.map((card) => (
        <div key={card.id}>{card.front}</div>
      ))}
    </div>
  );
}
```

#### ❌ NEVER: Fetch in Client Components
```typescript
// ❌ WRONG - Client component fetching
"use client";

import { useEffect, useState } from "react";
import { db } from "@/db";

export default function ClientComponent() {
  const [data, setData] = useState([]);
  
  useEffect(() => {
    // ❌ NEVER DO THIS - Database in client component
    const fetchData = async () => {
      const result = await db.select().from(table);
      setData(result);
    };
    fetchData();
  }, []);
  
  return <div>{/* ... */}</div>;
}
```

#### ❌ NEVER: Query directly in Server Components
```typescript
// ❌ WRONG - Direct database query in server component
import { db } from "@/db";
import { decksTable } from "@/db/schema";

export default async function Page() {
  // Don't query database directly
  const decks = await db.select().from(decksTable);
  return <div>...</div>;
}

// ✅ CORRECT - Use query helper
import { getUserDecks } from "@/db/queries/deck-queries";

export default async function Page() {
  const decks = await getUserDecks();
  return <div>...</div>;
}
```

---

## Mutation Helper Patterns

### Basic Mutation Helper Structure

```typescript
// src/db/queries/deck-mutations.ts
import { auth } from "@clerk/nextjs/server";
import { db } from "@/db";
import { decksTable } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import type { Deck } from "./types";

/**
 * Create a new deck for the authenticated user
 * @param name - Deck name
 * @param description - Optional deck description
 * @returns Created deck object
 * @throws Error if user is not authenticated
 */
export async function createDeck(
  name: string,
  description?: string
): Promise<Deck> {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  const [deck] = await db
    .insert(decksTable)
    .values({
      userId,
      name,
      description,
    })
    .returning();
  
  return deck;
}

/**
 * Update a deck with ownership verification
 * @param deckId - The deck ID to update
 * @param name - New deck name
 * @param description - New deck description
 * @returns Updated deck object or null if not found
 * @throws Error if user is not authenticated
 */
export async function updateDeck(
  deckId: number,
  name: string,
  description?: string
): Promise<Deck | null> {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  const [updated] = await db
    .update(decksTable)
    .set({
      name,
      description,
      updatedAt: new Date(),
    })
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
  
  return updated ?? null;
}

/**
 * Delete a deck with ownership verification
 * @param deckId - The deck ID to delete
 * @returns Deleted deck object or null if not found
 * @throws Error if user is not authenticated
 */
export async function deleteDeck(deckId: number): Promise<Deck | null> {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  const [deleted] = await db
    .delete(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
  
  return deleted ?? null;
}
```

---

## Server Actions Patterns

### Directory Structure
All Server Actions MUST be placed in the `src/app/actions/` directory:

```
src/app/actions/
├── deck-actions.ts
├── card-actions.ts
└── schemas.ts (Zod validation schemas)
```

### Server Action Structure (Validation + Mutation Helper)

```typescript
// src/app/actions/deck-actions.ts
"use server";

import { revalidatePath } from "next/cache";
import { z } from "zod";
import { createDeck as createDeckMutation } from "@/db/queries/deck-mutations";

// 1. Define Zod schema
const createDeckSchema = z.object({
  name: z
    .string()
    .min(1, "Deck name is required")
    .max(255, "Deck name must be 255 characters or less")
    .trim(),
  description: z
    .string()
    .max(1000, "Description must be 1000 characters or less")
    .trim()
    .optional(),
});

// 2. Infer TypeScript type from Zod schema
type CreateDeckInput = z.infer<typeof createDeckSchema>;

// 3. Define return type
type CreateDeckResult = 
  | { success: true; data: { id: number; name: string } }
  | { success: false; error: string };

// 4. Implement Server Action
export async function createDeck(
  input: CreateDeckInput
): Promise<CreateDeckResult> {
  try {
    // 5. Validate input with Zod
    const validationResult = createDeckSchema.safeParse(input);
    
    if (!validationResult.success) {
      return {
        success: false,
        error: validationResult.error.errors[0].message,
      };
    }
    
    const { name, description } = validationResult.data;
    
    // 6. Call mutation helper - it handles auth & database operation
    const deck = await createDeckMutation(name, description);
    
    // 7. Revalidate cache
    revalidatePath("/dashboard");
    
    // 8. Return success
    return {
      success: true,
      data: { id: deck.id, name: deck.name },
    };
  } catch (error) {
    console.error("Error creating deck:", error);
    
    // Handle specific errors
    if (error instanceof Error && error.message === "Unauthorized") {
      return { success: false, error: "Unauthorized" };
    }
    
    return {
      success: false,
      error: "Failed to create deck. Please try again.",
    };
  }
}
```

### Update Action Pattern

```typescript
// src/app/actions/deck-actions.ts
"use server";

import { revalidatePath } from "next/cache";
import { z } from "zod";
import { updateDeck as updateDeckMutation } from "@/db/queries/deck-mutations";

// Zod schema for update
const updateDeckSchema = z.object({
  id: z.number().int().positive(),
  name: z
    .string()
    .min(1, "Deck name is required")
    .max(255, "Deck name must be 255 characters or less")
    .trim(),
  description: z
    .string()
    .max(1000, "Description must be 1000 characters or less")
    .trim()
    .optional(),
});

type UpdateDeckInput = z.infer<typeof updateDeckSchema>;

type UpdateDeckResult =
  | { success: true; data: { id: number; name: string } }
  | { success: false; error: string };

export async function updateDeck(
  input: UpdateDeckInput
): Promise<UpdateDeckResult> {
  try {
    // Validate input
    const validationResult = updateDeckSchema.safeParse(input);
    
    if (!validationResult.success) {
      return {
        success: false,
        error: validationResult.error.errors[0].message,
      };
    }
    
    const { id, name, description } = validationResult.data;
    
    // Call mutation helper - it handles auth & ownership verification
    const updated = await updateDeckMutation(id, name, description);
    
    if (!updated) {
      return { success: false, error: "Deck not found" };
    }
    
    revalidatePath("/dashboard");
    revalidatePath(`/dashboard/decks/${id}`);
    
    return {
      success: true,
      data: { id: updated.id, name: updated.name },
    };
  } catch (error) {
    console.error("Error updating deck:", error);
    
    if (error instanceof Error && error.message === "Unauthorized") {
      return { success: false, error: "Unauthorized" };
    }
    
    return {
      success: false,
      error: "Failed to update deck. Please try again.",
    };
  }
}
```

### Delete Action Pattern

```typescript
// src/app/actions/deck-actions.ts
"use server";

import { revalidatePath } from "next/cache";
import { z } from "zod";
import { deleteDeck as deleteDeckMutation } from "@/db/queries/deck-mutations";

// Zod schema for delete
const deleteDeckSchema = z.object({
  id: z.number().int().positive(),
});

type DeleteDeckInput = z.infer<typeof deleteDeckSchema>;

type DeleteDeckResult =
  | { success: true }
  | { success: false; error: string };

export async function deleteDeck(
  input: DeleteDeckInput
): Promise<DeleteDeckResult> {
  try {
    // Validate input
    const validationResult = deleteDeckSchema.safeParse(input);
    
    if (!validationResult.success) {
      return {
        success: false,
        error: "Invalid deck ID",
      };
    }
    
    const { id } = validationResult.data;
    
    // Call mutation helper - it handles auth & ownership verification
    // This will CASCADE delete all cards in the deck
    const deleted = await deleteDeckMutation(id);
    
    if (!deleted) {
      return { success: false, error: "Deck not found" };
    }
    
    revalidatePath("/dashboard");
    
    return { success: true };
  } catch (error) {
    console.error("Error deleting deck:", error);
    
    if (error instanceof Error && error.message === "Unauthorized") {
      return { success: false, error: "Unauthorized" };
    }
    
    return {
      success: false,
      error: "Failed to delete deck. Please try again.",
    };
  }
}
```

### Card Actions with Deck Ownership Verification

```typescript
// src/app/actions/card-actions.ts
"use server";

import { revalidatePath } from "next/cache";
import { z } from "zod";
import { createCard as createCardMutation } from "@/db/queries/card-mutations";

// Zod schema for creating a card
const createCardSchema = z.object({
  deckId: z.number().int().positive(),
  front: z
    .string()
    .min(1, "Front of card is required")
    .max(5000, "Front must be 5000 characters or less")
    .trim(),
  back: z
    .string()
    .min(1, "Back of card is required")
    .max(5000, "Back must be 5000 characters or less")
    .trim(),
});

type CreateCardInput = z.infer<typeof createCardSchema>;

type CreateCardResult =
  | { success: true; data: { id: number } }
  | { success: false; error: string };

export async function createCard(
  input: CreateCardInput
): Promise<CreateCardResult> {
  try {
    // Validate input
    const validationResult = createCardSchema.safeParse(input);
    
    if (!validationResult.success) {
      return {
        success: false,
        error: validationResult.error.errors[0].message,
      };
    }
    
    const { deckId, front, back } = validationResult.data;
    
    // Call mutation helper - it handles auth & deck ownership verification
    const card = await createCardMutation(deckId, front, back);
    
    revalidatePath(`/dashboard/decks/${deckId}`);
    
    return {
      success: true,
      data: { id: card.id },
    };
  } catch (error) {
    console.error("Error creating card:", error);
    
    if (error instanceof Error && error.message === "Unauthorized") {
      return { success: false, error: "Unauthorized" };
    }
    
    if (error instanceof Error && error.message === "Deck not found") {
      return { success: false, error: "Deck not found" };
    }
    
    return {
      success: false,
      error: "Failed to create card. Please try again.",
    };
  }
}
```

### Card Mutation Helper Example

```typescript
// src/db/queries/card-mutations.ts
import { auth } from "@clerk/nextjs/server";
import { db } from "@/db";
import { cardsTable, decksTable } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import type { Card } from "./types";

/**
 * Create a card with deck ownership verification
 * @param deckId - The deck ID to add the card to
 * @param front - Front of the card
 * @param back - Back of the card
 * @returns Created card object
 * @throws Error if user is not authenticated or doesn't own the deck
 */
export async function createCard(
  deckId: number,
  front: string,
  back: string
): Promise<Card> {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // CRITICAL: Verify user owns the deck before creating card
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .limit(1);
  
  if (!deck) {
    throw new Error("Deck not found");
  }
  
  // Now safe to create card
  const [card] = await db
    .insert(cardsTable)
    .values({
      deckId,
      front,
      back,
    })
    .returning();
  
  return card;
}
```

---

## Zod Validation Patterns

### Common Zod Schemas

```typescript
// src/app/actions/schemas.ts
import { z } from "zod";

// String validations
export const deckNameSchema = z
  .string()
  .min(1, "Deck name is required")
  .max(255, "Deck name must be 255 characters or less")
  .trim();

export const descriptionSchema = z
  .string()
  .max(1000, "Description must be 1000 characters or less")
  .trim()
  .optional();

export const cardContentSchema = z
  .string()
  .min(1, "Content is required")
  .max(5000, "Content must be 5000 characters or less")
  .trim();

// ID validations
export const idSchema = z.number().int().positive();

export const optionalIdSchema = z.number().int().positive().optional();

// Email validation
export const emailSchema = z
  .string()
  .email("Invalid email address")
  .toLowerCase()
  .trim();

// URL validation
export const urlSchema = z
  .string()
  .url("Invalid URL")
  .trim();

// Date validation
export const dateSchema = z.coerce.date();

// Enum validation
export const deckVisibilitySchema = z.enum(["private", "public", "shared"], {
  errorMap: () => ({ message: "Invalid visibility setting" }),
});

// Boolean validation
export const booleanSchema = z.boolean();

// Array validation
export const deckIdsSchema = z
  .array(z.number().int().positive())
  .min(1, "At least one deck ID is required")
  .max(100, "Too many deck IDs");
```

### Complex Zod Schemas

```typescript
// Nested object validation
const createDeckWithCardsSchema = z.object({
  deck: z.object({
    name: deckNameSchema,
    description: descriptionSchema,
  }),
  cards: z
    .array(
      z.object({
        front: cardContentSchema,
        back: cardContentSchema,
      })
    )
    .min(1, "At least one card is required")
    .max(100, "Maximum 100 cards per operation"),
});

// Discriminated union
const deckActionSchema = z.discriminatedUnion("action", [
  z.object({
    action: z.literal("create"),
    name: deckNameSchema,
    description: descriptionSchema,
  }),
  z.object({
    action: z.literal("update"),
    id: idSchema,
    name: deckNameSchema,
    description: descriptionSchema,
  }),
  z.object({
    action: z.literal("delete"),
    id: idSchema,
  }),
]);

// Refinement for custom validation
const cardSchema = z
  .object({
    front: cardContentSchema,
    back: cardContentSchema,
  })
  .refine(
    (data) => data.front !== data.back,
    {
      message: "Front and back cannot be identical",
      path: ["back"],
    }
  );

// Transform data
const deckInputSchema = z.object({
  name: z.string().transform((val) => val.trim()),
  tags: z.string().transform((val) => 
    val.split(",").map((tag) => tag.trim()).filter(Boolean)
  ),
});
```

### Zod Error Handling

```typescript
// Server action with detailed error handling
export async function createDeckDetailed(
  input: unknown
): Promise<CreateDeckResult> {
  try {
    const { userId } = await auth();
    
    if (!userId) {
      return { success: false, error: "Unauthorized" };
    }
    
    // Validate with detailed error messages
    const validationResult = createDeckSchema.safeParse(input);
    
    if (!validationResult.success) {
      // Get all validation errors
      const errors = validationResult.error.errors.map((err) => ({
        field: err.path.join("."),
        message: err.message,
      }));
      
      // Return first error message or combine them
      return {
        success: false,
        error: errors[0].message,
        // Optional: return all errors
        // errors: errors,
      };
    }
    
    const validatedData = validationResult.data;
    
    // Continue with database operation...
    
  } catch (error) {
    console.error("Error:", error);
    return {
      success: false,
      error: "An unexpected error occurred",
    };
  }
}
```

---

## Client Component Integration

### Calling Server Actions from Client Components

```typescript
// src/components/create-deck-form.tsx
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { createDeck } from "@/app/actions/deck-actions";

export function CreateDeckForm() {
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  
  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setError(null);
    setIsLoading(true);
    
    try {
      // Call server action with typed data
      const result = await createDeck({ name, description });
      
      if (!result.success) {
        setError(result.error);
        return;
      }
      
      // Success - reset form
      setName("");
      setDescription("");
      
      // Optional: show success message or redirect
    } catch (err) {
      setError("An unexpected error occurred");
    } finally {
      setIsLoading(false);
    }
  }
  
  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <Label htmlFor="name">Deck Name</Label>
        <Input
          id="name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          disabled={isLoading}
          required
        />
      </div>
      
      <div>
        <Label htmlFor="description">Description (Optional)</Label>
        <Textarea
          id="description"
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          disabled={isLoading}
        />
      </div>
      
      {error && (
        <div className="text-sm text-red-600" role="alert">
          {error}
        </div>
      )}
      
      <Button type="submit" disabled={isLoading}>
        {isLoading ? "Creating..." : "Create Deck"}
      </Button>
    </form>
  );
}
```

### Using Server Actions with useTransition

```typescript
"use client";

import { useTransition } from "react";
import { Button } from "@/components/ui/button";
import { deleteDeck } from "@/app/actions/deck-actions";

interface DeleteDeckButtonProps {
  deckId: number;
  deckName: string;
}

export function DeleteDeckButton({ deckId, deckName }: DeleteDeckButtonProps) {
  const [isPending, startTransition] = useTransition();
  
  function handleDelete() {
    if (!confirm(`Are you sure you want to delete "${deckName}"?`)) {
      return;
    }
    
    startTransition(async () => {
      const result = await deleteDeck({ id: deckId });
      
      if (!result.success) {
        alert(result.error);
      }
    });
  }
  
  return (
    <Button
      variant="destructive"
      onClick={handleDelete}
      disabled={isPending}
    >
      {isPending ? "Deleting..." : "Delete"}
    </Button>
  );
}
```

### Using Server Actions with useActionState (React 19)

```typescript
"use client";

import { useActionState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { createDeck } from "@/app/actions/deck-actions";

export function CreateDeckFormWithActionState() {
  const [state, formAction, isPending] = useActionState(
    async (_prevState: unknown, formData: FormData) => {
      // Extract and type data from FormData
      const name = formData.get("name") as string;
      const description = formData.get("description") as string;
      
      // Call server action with typed data
      return await createDeck({ name, description });
    },
    null
  );
  
  return (
    <form action={formAction} className="space-y-4">
      <div>
        <Label htmlFor="name">Deck Name</Label>
        <Input
          id="name"
          name="name"
          required
          disabled={isPending}
        />
      </div>
      
      <div>
        <Label htmlFor="description">Description</Label>
        <Input
          id="description"
          name="description"
          disabled={isPending}
        />
      </div>
      
      {state && !state.success && (
        <div className="text-sm text-red-600" role="alert">
          {state.error}
        </div>
      )}
      
      {state && state.success && (
        <div className="text-sm text-green-600" role="alert">
          Deck created successfully!
        </div>
      )}
      
      <Button type="submit" disabled={isPending}>
        {isPending ? "Creating..." : "Create Deck"}
      </Button>
    </form>
  );
}
```

---

## Type Safety Patterns

### Using Shared Types

All types are defined in `src/db/queries/types.ts` and should be imported where needed:

```typescript
// In query helpers
import type { Deck, Card } from "./types";

// In Server Actions or components
import type { Deck, Card, ActionResult } from "@/db/queries/types";
```

### Type Guards

```typescript
// src/lib/type-guards.ts
import type { ActionResult } from "@/db/queries/types";

export function isActionSuccess<T>(
  result: ActionResult<T>
): result is { success: true; data: T } {
  return result.success === true;
}

export function isActionError<T>(
  result: ActionResult<T>
): result is { success: false; error: string } {
  return result.success === false;
}

// Usage in components
const result = await createDeck({ name, description });

if (isActionSuccess(result)) {
  console.log("Created deck:", result.data);
} else {
  console.error("Error:", result.error);
}
```

---

## Prohibited Practices

### ❌ NEVER: Direct Database Queries in Server Components or Actions

```typescript
// ❌ WRONG - Direct database query in Server Component
import { db } from "@/db";
import { decksTable } from "@/db/schema";

export default async function Page() {
  const decks = await db.select().from(decksTable);
  return <div>...</div>;
}

// ✅ CORRECT - Use query helper
import { getUserDecks } from "@/db/queries/deck-queries";

export default async function Page() {
  const decks = await getUserDecks();
  return <div>...</div>;
}
```

```typescript
// ❌ WRONG - Direct database mutation in Server Action
"use server";
import { db } from "@/db";
import { decksTable } from "@/db/schema";

export async function createDeck(name: string) {
  const [deck] = await db.insert(decksTable).values({ name });
  return deck;
}

// ✅ CORRECT - Use mutation helper
"use server";
import { createDeck as createDeckMutation } from "@/db/queries/deck-mutations";

export async function createDeck(name: string) {
  const deck = await createDeckMutation(name);
  return deck;
}
```

### ❌ NEVER: Use FormData as Parameter Type

```typescript
// ❌ WRONG - FormData as parameter type
export async function createDeck(formData: FormData) {
  const name = formData.get("name");
  // ...
}

// ✅ CORRECT - Typed parameters
export async function createDeck(input: CreateDeckInput) {
  const { name, description } = input;
  // ...
}
```

### ❌ NEVER: Skip Zod Validation in Server Actions

```typescript
// ❌ WRONG - No validation before calling mutation helper
"use server";
import { createDeck as createDeckMutation } from "@/db/queries/deck-mutations";

export async function createDeck(input: CreateDeckInput) {
  // Directly calling mutation without validation
  const deck = await createDeckMutation(input.name, input.description);
  return deck;
}

// ✅ CORRECT - Always validate with Zod first
"use server";
import { z } from "zod";
import { createDeck as createDeckMutation } from "@/db/queries/deck-mutations";

const createDeckSchema = z.object({
  name: z.string().min(1).max(255).trim(),
  description: z.string().max(1000).trim().optional(),
});

export async function createDeck(input: CreateDeckInput) {
  const validationResult = createDeckSchema.safeParse(input);
  if (!validationResult.success) {
    return { success: false, error: "Validation failed" };
  }
  
  const { name, description } = validationResult.data;
  const deck = await createDeckMutation(name, description);
  return { success: true, data: deck };
}
```

### ❌ NEVER: Mutate in Server Components

```typescript
// ❌ WRONG - Calling mutation in server component
import { createDeck } from "@/db/queries/deck-mutations";

export default async function Page() {
  // Don't call mutations in server components
  await createDeck("New Deck");
  
  return <div>...</div>;
}

// ✅ CORRECT - Use server action from client component
import { getUserDecks } from "@/db/queries/deck-queries";

export default async function Page() {
  // Only call query helpers in server components
  const decks = await getUserDecks();
  
  return <CreateDeckForm />;
}
```

### ❌ NEVER: Skip Auth in Query/Mutation Helpers

```typescript
// ❌ WRONG - No auth check in query helper
// src/db/queries/deck-queries.ts
export async function getUserDecks() {
  // Missing auth check!
  const decks = await db.select().from(decksTable);
  return decks;
}

// ✅ CORRECT - Always include auth check
// src/db/queries/deck-queries.ts
import { auth } from "@clerk/nextjs/server";

export async function getUserDecks() {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
  
  return decks;
}
```

---

## Testing Patterns

### Testing Server Actions

```typescript
// src/app/actions/__tests__/deck-actions.test.ts
import { describe, it, expect, vi } from "vitest";
import { createDeck } from "../deck-actions";

// Mock auth
vi.mock("@clerk/nextjs/server", () => ({
  auth: vi.fn(() => Promise.resolve({ userId: "test-user-id" })),
}));

// Mock database
vi.mock("@/db", () => ({
  db: {
    insert: vi.fn(() => ({
      values: vi.fn(() => ({
        returning: vi.fn(() => [{ id: 1, name: "Test Deck" }]),
      })),
    })),
  },
}));

describe("createDeck", () => {
  it("should validate input and create deck", async () => {
    const result = await createDeck({
      name: "Test Deck",
      description: "Test Description",
    });
    
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.name).toBe("Test Deck");
    }
  });
  
  it("should return error for invalid input", async () => {
    const result = await createDeck({
      name: "", // Empty name
      description: "Test",
    });
    
    expect(result.success).toBe(false);
    if (!result.success) {
      expect(result.error).toContain("required");
    }
  });
});
```

---

## Best Practices Summary

### Query Helper Checklist (`src/db/queries/*-queries.ts`)
- [ ] Place in `src/db/queries/` directory
- [ ] Name file with `-queries.ts` suffix for reads
- [ ] Call `auth()` at the start of every function
- [ ] Check `if (!userId)` and throw error
- [ ] Verify ownership in WHERE clause with `eq(table.userId, userId)`
- [ ] Handle not found cases (return null or throw)
- [ ] Add JSDoc comments for all functions
- [ ] Use proper TypeScript return types
- [ ] Never expose internal database structure

### Mutation Helper Checklist (`src/db/queries/*-mutations.ts`)
- [ ] Place in `src/db/queries/` directory
- [ ] Name file with `-mutations.ts` suffix for writes
- [ ] Call `auth()` at the start of every function
- [ ] Check `if (!userId)` and throw error
- [ ] Verify ownership before updates/deletes
- [ ] Use `.returning()` for insert/update/delete
- [ ] Update `updatedAt` manually on updates
- [ ] Add JSDoc comments for all functions
- [ ] Throw descriptive errors
- [ ] Use proper TypeScript return types

### Server Component Checklist
- [ ] Import query helpers from `@/db/queries/`
- [ ] Call query helpers, never direct db queries
- [ ] Handle errors with try/catch
- [ ] Redirect on authentication errors
- [ ] Never call mutation helpers
- [ ] Keep components focused on presentation

### Server Action Checklist
- [ ] Place in `src/app/actions/` directory
- [ ] Add `"use server"` directive
- [ ] Define Zod schema for validation
- [ ] Infer TypeScript type from Zod schema
- [ ] Validate input with `safeParse()` BEFORE calling helper
- [ ] Call mutation helper from `@/db/queries/`
- [ ] Use try/catch for error handling
- [ ] Handle specific error messages (Unauthorized, Not found)
- [ ] Return typed result objects
- [ ] Call `revalidatePath()` after mutations
- [ ] Never use `FormData` as parameter type
- [ ] Never do direct database operations

### Zod Validation Checklist
- [ ] Create schema in Server Action file
- [ ] Use `.safeParse()` not `.parse()`
- [ ] Handle validation errors gracefully
- [ ] Use `.trim()` for string inputs
- [ ] Set appropriate min/max constraints
- [ ] Add clear error messages
- [ ] Use `.refine()` for custom validations

### Type Safety Checklist
- [ ] Define explicit parameter types
- [ ] Define explicit return types
- [ ] Use Drizzle's inferred types for database models
- [ ] Create shared types in `src/db/queries/types.ts`
- [ ] Use type guards where appropriate
- [ ] Never use `any` type

---

## Quick Reference

### Query Helper Template
```typescript
// src/db/queries/deck-queries.ts
import { auth } from "@clerk/nextjs/server";
import { db } from "@/db";
import { decksTable } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import type { Deck } from "./types";

/**
 * Get all decks for the authenticated user
 * @returns Array of decks
 * @throws Error if user is not authenticated
 */
export async function getUserDecks(): Promise<Deck[]> {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
  
  return decks;
}
```

### Mutation Helper Template
```typescript
// src/db/queries/deck-mutations.ts
import { auth } from "@clerk/nextjs/server";
import { db } from "@/db";
import { decksTable } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import type { Deck } from "./types";

/**
 * Create a new deck
 * @param name - Deck name
 * @param description - Optional description
 * @returns Created deck
 * @throws Error if user is not authenticated
 */
export async function createDeck(
  name: string,
  description?: string
): Promise<Deck> {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  const [deck] = await db
    .insert(decksTable)
    .values({ userId, name, description })
    .returning();
  
  return deck;
}
```

### Server Action Template
```typescript
// src/app/actions/deck-actions.ts
"use server";

import { revalidatePath } from "next/cache";
import { z } from "zod";
import { createDeck as createDeckMutation } from "@/db/queries/deck-mutations";

const inputSchema = z.object({
  name: z.string().min(1).max(255).trim(),
  description: z.string().max(1000).trim().optional(),
});

type Input = z.infer<typeof inputSchema>;

type Result = 
  | { success: true; data: { id: number; name: string } }
  | { success: false; error: string };

export async function createDeck(input: Input): Promise<Result> {
  try {
    // Validate input
    const validation = inputSchema.safeParse(input);
    if (!validation.success) {
      return { 
        success: false, 
        error: validation.error.errors[0].message 
      };
    }
    
    const { name, description } = validation.data;
    
    // Call mutation helper
    const deck = await createDeckMutation(name, description);
    
    // Revalidate
    revalidatePath("/dashboard");
    
    return { 
      success: true, 
      data: { id: deck.id, name: deck.name } 
    };
  } catch (error) {
    console.error("Error:", error);
    
    if (error instanceof Error && error.message === "Unauthorized") {
      return { success: false, error: "Unauthorized" };
    }
    
    return { success: false, error: "Operation failed" };
  }
}
```

### Server Component Template
```typescript
// src/app/dashboard/page.tsx
import { redirect } from "next/navigation";
import { getUserDecks } from "@/db/queries/deck-queries";

export default async function DashboardPage() {
  let decks;
  
  try {
    // Call query helper
    decks = await getUserDecks();
  } catch (error) {
    // Handle auth error
    redirect("/");
  }
  
  return (
    <div>
      {decks.map((deck) => (
        <div key={deck.id}>{deck.name}</div>
      ))}
    </div>
  );
}
```

---

**Remember: ALL database operations go through helpers in `src/db/queries/`. Server Components call query helpers. Server Actions validate with Zod, then call mutation helpers. No exceptions.**
